{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GatewayTokenActionCreatorImplementation = void 0;\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nconst types_1 = require(\"../types\");\n\nconst logger_1 = __importDefault(require(\"../logger\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst GatewayTokenActionCreatorImplementation = _ref => {\n  let {\n    wallet,\n    chainImplementation,\n    gatekeeperClient,\n    dispatch,\n    networkConfig,\n    ownerSigns\n  } = _ref;\n\n  const logDebug = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(`[useChain] ${message}`, obj);\n  };\n\n  const logError = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.error(`[useChain] ${message}`, obj);\n  };\n\n  const isTokenCreated = code => code === types_1.GatekeeperAPIStatus.ISSUED;\n\n  const isTokenPending = code => code === types_1.GatekeeperAPIStatus.REQUESTED;\n\n  const isRequestedRetriesExhausted = code => code === types_1.GatekeeperAPIStatus.REQUESTED_RETRIES_EXHAUSTED;\n\n  const isFailure = code => !isTokenPending(code) && !isRequestedRetriesExhausted(code) && code >= 400;\n\n  const pollForActiveOnChainToken = async function () {\n    let pollChainNumberRetries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : networkConfig.pollChainNumberRetries;\n    return (0, utils_1.pollUntilConditionMet)(chainImplementation.findGatewayToken, onChainToken => {\n      if (!onChainToken) return false; // keep polling\n\n      if (!onChainToken.expiryTime) return true;\n      if (onChainToken.state === types_1.State.ACTIVE) return true;\n      throw new Error('Token found but not ACTIVE');\n    }, networkConfig.pollChainIntervalMilliseconds, pollChainNumberRetries);\n  };\n\n  const waitForGatewayToken = async function () {\n    let pollChainNumberRetries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : networkConfig.pollChainNumberRetries;\n\n    // poll the gatekeeper until we have a status for a created record\n    // if we don't get a created token, then we consider it a failure\n    try {\n      // Show the awaiting transaction screen if this is an owner signs transaction\n      if (ownerSigns) {\n        dispatch({\n          type: 'civicPass_awaiting_owner_transaction'\n        });\n      }\n\n      const token = await pollForActiveOnChainToken(pollChainNumberRetries);\n      logDebug('Result from pollForActiveOnChainToken', token);\n\n      if (!token) {\n        logError('Token not found onChain');\n        throw new Error('Token not found onChain');\n      }\n\n      dispatch({\n        type: 'tokenChange',\n        token\n      });\n      dispatch({\n        type: 'civicPass_check_token_status',\n        token\n      });\n      return;\n    } catch (error) {\n      logError('Error polling for active token on chain', error); // If owner signs is true then fail the flow without checking the gatekeeper\n\n      if (ownerSigns) {\n        logError('Failed to find Gateway token on-chain with ownerSigns:true, failing');\n        dispatch({\n          type: 'civicPass_owner_transaction_timeout'\n        });\n        return;\n      }\n\n      logError('Failed to find Gateway token on-chain with ownerSigns:false, checking with gatekeeper');\n      const gkApiStatus = await gatekeeperClient().getGatekeeperStatus(wallet.publicKey);\n\n      if (isRequestedRetriesExhausted(gkApiStatus)) {\n        logError('Retried exhausted', {\n          gkApiStatus\n        });\n        dispatch({\n          type: 'civicPass_requested_retries_exhausted'\n        });\n        return;\n      } // if the token is still pending or in review then keep polling on-chain\n\n\n      if (isTokenPending(gkApiStatus)) {\n        // we don't want to wait the whole amount of time if we've got to here, so just 4 retries = 3 x 2 seconds, a further\n        // 6 seconds before we will ask the GK API for status again\n        await waitForGatewayToken(3);\n      } // retries have been exhausted and we still don't have a token\n      // or the gatekeeper threw an error during issuance attempt\n\n\n      if (isTokenCreated(gkApiStatus) || isFailure(gkApiStatus)) {\n        logError('Failed to find Gateway token with gatekeeper status code', types_1.GatekeeperAPIStatus[gkApiStatus]);\n        dispatch({\n          type: 'tokenNotFoundError'\n        });\n      }\n    }\n  };\n\n  return {\n    waitForGatewayToken\n  };\n};\n\nexports.GatewayTokenActionCreatorImplementation = GatewayTokenActionCreatorImplementation;","map":{"version":3,"sources":["/workspace/0x2Hacks.github.io/candy-machine-ui/node_modules/@civic/common-gateway-react/dist/esm/actionCreator/gatewayToken.actionCreator.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","GatewayTokenActionCreatorImplementation","types_1","require","logger_1","utils_1","wallet","chainImplementation","gatekeeperClient","dispatch","networkConfig","ownerSigns","logDebug","message","obj","default","debug","logError","error","isTokenCreated","code","GatekeeperAPIStatus","ISSUED","isTokenPending","REQUESTED","isRequestedRetriesExhausted","REQUESTED_RETRIES_EXHAUSTED","isFailure","pollForActiveOnChainToken","pollChainNumberRetries","pollUntilConditionMet","findGatewayToken","onChainToken","expiryTime","state","State","ACTIVE","Error","pollChainIntervalMilliseconds","waitForGatewayToken","type","token","gkApiStatus","getGatekeeperStatus","publicKey"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GatewayTokenActionCreatorImplementation = void 0;\n/* eslint-disable @typescript-eslint/no-unused-vars */\nconst types_1 = require(\"../types\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst utils_1 = require(\"./utils\");\nconst GatewayTokenActionCreatorImplementation = ({ wallet, chainImplementation, gatekeeperClient, dispatch, networkConfig, ownerSigns, }) => {\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useChain] ${message}`, obj);\n    const logError = (message, obj = null) => logger_1.default.error(`[useChain] ${message}`, obj);\n    const isTokenCreated = (code) => code === types_1.GatekeeperAPIStatus.ISSUED;\n    const isTokenPending = (code) => code === types_1.GatekeeperAPIStatus.REQUESTED;\n    const isRequestedRetriesExhausted = (code) => code === types_1.GatekeeperAPIStatus.REQUESTED_RETRIES_EXHAUSTED;\n    const isFailure = (code) => !isTokenPending(code) && !isRequestedRetriesExhausted(code) && code >= 400;\n    const pollForActiveOnChainToken = async (pollChainNumberRetries = networkConfig.pollChainNumberRetries) => {\n        return (0, utils_1.pollUntilConditionMet)(chainImplementation.findGatewayToken, (onChainToken) => {\n            if (!onChainToken)\n                return false; // keep polling\n            if (!onChainToken.expiryTime)\n                return true;\n            if (onChainToken.state === types_1.State.ACTIVE)\n                return true;\n            throw new Error('Token found but not ACTIVE');\n        }, networkConfig.pollChainIntervalMilliseconds, pollChainNumberRetries);\n    };\n    const waitForGatewayToken = async (pollChainNumberRetries = networkConfig.pollChainNumberRetries) => {\n        // poll the gatekeeper until we have a status for a created record\n        // if we don't get a created token, then we consider it a failure\n        try {\n            // Show the awaiting transaction screen if this is an owner signs transaction\n            if (ownerSigns) {\n                dispatch({ type: 'civicPass_awaiting_owner_transaction' });\n            }\n            const token = await pollForActiveOnChainToken(pollChainNumberRetries);\n            logDebug('Result from pollForActiveOnChainToken', token);\n            if (!token) {\n                logError('Token not found onChain');\n                throw new Error('Token not found onChain');\n            }\n            dispatch({ type: 'tokenChange', token });\n            dispatch({ type: 'civicPass_check_token_status', token });\n            return;\n        }\n        catch (error) {\n            logError('Error polling for active token on chain', error);\n            // If owner signs is true then fail the flow without checking the gatekeeper\n            if (ownerSigns) {\n                logError('Failed to find Gateway token on-chain with ownerSigns:true, failing');\n                dispatch({ type: 'civicPass_owner_transaction_timeout' });\n                return;\n            }\n            logError('Failed to find Gateway token on-chain with ownerSigns:false, checking with gatekeeper');\n            const gkApiStatus = await gatekeeperClient().getGatekeeperStatus(wallet.publicKey);\n            if (isRequestedRetriesExhausted(gkApiStatus)) {\n                logError('Retried exhausted', { gkApiStatus });\n                dispatch({ type: 'civicPass_requested_retries_exhausted' });\n                return;\n            }\n            // if the token is still pending or in review then keep polling on-chain\n            if (isTokenPending(gkApiStatus)) {\n                // we don't want to wait the whole amount of time if we've got to here, so just 4 retries = 3 x 2 seconds, a further\n                // 6 seconds before we will ask the GK API for status again\n                await waitForGatewayToken(3);\n            }\n            // retries have been exhausted and we still don't have a token\n            // or the gatekeeper threw an error during issuance attempt\n            if (isTokenCreated(gkApiStatus) || isFailure(gkApiStatus)) {\n                logError('Failed to find Gateway token with gatekeeper status code', types_1.GatekeeperAPIStatus[gkApiStatus]);\n                dispatch({ type: 'tokenNotFoundError' });\n            }\n        }\n    };\n    return {\n        waitForGatewayToken,\n    };\n};\nexports.GatewayTokenActionCreatorImplementation = GatewayTokenActionCreatorImplementation;\n"]},"metadata":{},"sourceType":"script"}