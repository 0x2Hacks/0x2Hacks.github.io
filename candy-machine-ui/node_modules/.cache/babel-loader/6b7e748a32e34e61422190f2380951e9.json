{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/workspace/0x2Hacks.github.io/candy-machine-ui/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _asyncToGenerator = require(\"/workspace/0x2Hacks.github.io/candy-machine-ui/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GatewayTokenActionCreatorImplementation = void 0;\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nvar types_1 = require(\"../types\");\n\nvar logger_1 = __importDefault(require(\"../logger\"));\n\nvar utils_1 = require(\"./utils\");\n\nvar GatewayTokenActionCreatorImplementation = function GatewayTokenActionCreatorImplementation(_ref) {\n  var wallet = _ref.wallet,\n      chainImplementation = _ref.chainImplementation,\n      gatekeeperClient = _ref.gatekeeperClient,\n      dispatch = _ref.dispatch,\n      networkConfig = _ref.networkConfig,\n      ownerSigns = _ref.ownerSigns;\n\n  var logDebug = function logDebug(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(\"[useChain] \".concat(message), obj);\n  };\n\n  var logError = function logError(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.error(\"[useChain] \".concat(message), obj);\n  };\n\n  var isTokenCreated = function isTokenCreated(code) {\n    return code === types_1.GatekeeperAPIStatus.ISSUED;\n  };\n\n  var isTokenPending = function isTokenPending(code) {\n    return code === types_1.GatekeeperAPIStatus.REQUESTED;\n  };\n\n  var isRequestedRetriesExhausted = function isRequestedRetriesExhausted(code) {\n    return code === types_1.GatekeeperAPIStatus.REQUESTED_RETRIES_EXHAUSTED;\n  };\n\n  var isFailure = function isFailure(code) {\n    return !isTokenPending(code) && !isRequestedRetriesExhausted(code) && code >= 400;\n  };\n\n  var pollForActiveOnChainToken = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var pollChainNumberRetries,\n          _args = arguments;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              pollChainNumberRetries = _args.length > 0 && _args[0] !== undefined ? _args[0] : networkConfig.pollChainNumberRetries;\n              return _context.abrupt(\"return\", (0, utils_1.pollUntilConditionMet)(chainImplementation.findGatewayToken, function (onChainToken) {\n                if (!onChainToken) return false; // keep polling\n\n                // keep polling\n                if (!onChainToken.expiryTime) return true;\n                if (onChainToken.state === types_1.State.ACTIVE) return true;\n                throw new Error('Token found but not ACTIVE');\n              }, networkConfig.pollChainIntervalMilliseconds, pollChainNumberRetries));\n\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function pollForActiveOnChainToken() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var waitForGatewayToken = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var pollChainNumberRetries,\n          token,\n          gkApiStatus,\n          _args2 = arguments;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              pollChainNumberRetries = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : networkConfig.pollChainNumberRetries;\n              _context2.prev = 1;\n\n              // Show the awaiting transaction screen if this is an owner signs transaction\n              if (ownerSigns) {\n                dispatch({\n                  type: 'civicPass_awaiting_owner_transaction'\n                });\n              }\n\n              _context2.next = 5;\n              return pollForActiveOnChainToken(pollChainNumberRetries);\n\n            case 5:\n              token = _context2.sent;\n              logDebug('Result from pollForActiveOnChainToken', token);\n\n              if (token) {\n                _context2.next = 10;\n                break;\n              }\n\n              logError('Token not found onChain');\n              throw new Error('Token not found onChain');\n\n            case 10:\n              dispatch({\n                type: 'tokenChange',\n                token: token\n              });\n              dispatch({\n                type: 'civicPass_check_token_status',\n                token: token\n              });\n              return _context2.abrupt(\"return\");\n\n            case 15:\n              _context2.prev = 15;\n              _context2.t0 = _context2[\"catch\"](1);\n              logError('Error polling for active token on chain', _context2.t0); // If owner signs is true then fail the flow without checking the gatekeeper\n\n              if (!ownerSigns) {\n                _context2.next = 22;\n                break;\n              }\n\n              logError('Failed to find Gateway token on-chain with ownerSigns:true, failing');\n              dispatch({\n                type: 'civicPass_owner_transaction_timeout'\n              });\n              return _context2.abrupt(\"return\");\n\n            case 22:\n              logError('Failed to find Gateway token on-chain with ownerSigns:false, checking with gatekeeper');\n              _context2.next = 25;\n              return gatekeeperClient().getGatekeeperStatus(wallet.publicKey);\n\n            case 25:\n              gkApiStatus = _context2.sent;\n\n              if (!isRequestedRetriesExhausted(gkApiStatus)) {\n                _context2.next = 30;\n                break;\n              }\n\n              logError('Retried exhausted', {\n                gkApiStatus: gkApiStatus\n              });\n              dispatch({\n                type: 'civicPass_requested_retries_exhausted'\n              });\n              return _context2.abrupt(\"return\");\n\n            case 30:\n              if (!isTokenPending(gkApiStatus)) {\n                _context2.next = 33;\n                break;\n              }\n\n              _context2.next = 33;\n              return waitForGatewayToken(3);\n\n            case 33:\n              // retries have been exhausted and we still don't have a token\n              // or the gatekeeper threw an error during issuance attempt\n              if (isTokenCreated(gkApiStatus) || isFailure(gkApiStatus)) {\n                logError('Failed to find Gateway token with gatekeeper status code', types_1.GatekeeperAPIStatus[gkApiStatus]);\n                dispatch({\n                  type: 'tokenNotFoundError'\n                });\n              }\n\n            case 34:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[1, 15]]);\n    }));\n\n    return function waitForGatewayToken() {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  return {\n    waitForGatewayToken: waitForGatewayToken\n  };\n};\n\nexports.GatewayTokenActionCreatorImplementation = GatewayTokenActionCreatorImplementation;","map":{"version":3,"sources":["/workspace/0x2Hacks.github.io/candy-machine-ui/node_modules/@civic/common-gateway-react/dist/esm/actionCreator/gatewayToken.actionCreator.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","GatewayTokenActionCreatorImplementation","types_1","require","logger_1","utils_1","wallet","chainImplementation","gatekeeperClient","dispatch","networkConfig","ownerSigns","logDebug","message","obj","default","debug","logError","error","isTokenCreated","code","GatekeeperAPIStatus","ISSUED","isTokenPending","REQUESTED","isRequestedRetriesExhausted","REQUESTED_RETRIES_EXHAUSTED","isFailure","pollForActiveOnChainToken","pollChainNumberRetries","pollUntilConditionMet","findGatewayToken","onChainToken","expiryTime","state","State","ACTIVE","Error","pollChainIntervalMilliseconds","waitForGatewayToken","type","token","getGatekeeperStatus","publicKey","gkApiStatus"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GatewayTokenActionCreatorImplementation = void 0;\n/* eslint-disable @typescript-eslint/no-unused-vars */\nconst types_1 = require(\"../types\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst utils_1 = require(\"./utils\");\nconst GatewayTokenActionCreatorImplementation = ({ wallet, chainImplementation, gatekeeperClient, dispatch, networkConfig, ownerSigns, }) => {\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useChain] ${message}`, obj);\n    const logError = (message, obj = null) => logger_1.default.error(`[useChain] ${message}`, obj);\n    const isTokenCreated = (code) => code === types_1.GatekeeperAPIStatus.ISSUED;\n    const isTokenPending = (code) => code === types_1.GatekeeperAPIStatus.REQUESTED;\n    const isRequestedRetriesExhausted = (code) => code === types_1.GatekeeperAPIStatus.REQUESTED_RETRIES_EXHAUSTED;\n    const isFailure = (code) => !isTokenPending(code) && !isRequestedRetriesExhausted(code) && code >= 400;\n    const pollForActiveOnChainToken = async (pollChainNumberRetries = networkConfig.pollChainNumberRetries) => {\n        return (0, utils_1.pollUntilConditionMet)(chainImplementation.findGatewayToken, (onChainToken) => {\n            if (!onChainToken)\n                return false; // keep polling\n            if (!onChainToken.expiryTime)\n                return true;\n            if (onChainToken.state === types_1.State.ACTIVE)\n                return true;\n            throw new Error('Token found but not ACTIVE');\n        }, networkConfig.pollChainIntervalMilliseconds, pollChainNumberRetries);\n    };\n    const waitForGatewayToken = async (pollChainNumberRetries = networkConfig.pollChainNumberRetries) => {\n        // poll the gatekeeper until we have a status for a created record\n        // if we don't get a created token, then we consider it a failure\n        try {\n            // Show the awaiting transaction screen if this is an owner signs transaction\n            if (ownerSigns) {\n                dispatch({ type: 'civicPass_awaiting_owner_transaction' });\n            }\n            const token = await pollForActiveOnChainToken(pollChainNumberRetries);\n            logDebug('Result from pollForActiveOnChainToken', token);\n            if (!token) {\n                logError('Token not found onChain');\n                throw new Error('Token not found onChain');\n            }\n            dispatch({ type: 'tokenChange', token });\n            dispatch({ type: 'civicPass_check_token_status', token });\n            return;\n        }\n        catch (error) {\n            logError('Error polling for active token on chain', error);\n            // If owner signs is true then fail the flow without checking the gatekeeper\n            if (ownerSigns) {\n                logError('Failed to find Gateway token on-chain with ownerSigns:true, failing');\n                dispatch({ type: 'civicPass_owner_transaction_timeout' });\n                return;\n            }\n            logError('Failed to find Gateway token on-chain with ownerSigns:false, checking with gatekeeper');\n            const gkApiStatus = await gatekeeperClient().getGatekeeperStatus(wallet.publicKey);\n            if (isRequestedRetriesExhausted(gkApiStatus)) {\n                logError('Retried exhausted', { gkApiStatus });\n                dispatch({ type: 'civicPass_requested_retries_exhausted' });\n                return;\n            }\n            // if the token is still pending or in review then keep polling on-chain\n            if (isTokenPending(gkApiStatus)) {\n                // we don't want to wait the whole amount of time if we've got to here, so just 4 retries = 3 x 2 seconds, a further\n                // 6 seconds before we will ask the GK API for status again\n                await waitForGatewayToken(3);\n            }\n            // retries have been exhausted and we still don't have a token\n            // or the gatekeeper threw an error during issuance attempt\n            if (isTokenCreated(gkApiStatus) || isFailure(gkApiStatus)) {\n                logError('Failed to find Gateway token with gatekeeper status code', types_1.GatekeeperAPIStatus[gkApiStatus]);\n                dispatch({ type: 'tokenNotFoundError' });\n            }\n        }\n    };\n    return {\n        waitForGatewayToken,\n    };\n};\nexports.GatewayTokenActionCreatorImplementation = GatewayTokenActionCreatorImplementation;\n"]},"metadata":{},"sourceType":"script"}