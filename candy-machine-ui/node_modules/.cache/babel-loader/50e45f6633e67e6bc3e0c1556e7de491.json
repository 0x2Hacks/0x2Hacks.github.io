{"ast":null,"code":"import _toConsumableArray from\"/workspace/0x2Hacks.github.io/candy-machine-ui/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _asyncToGenerator from\"/workspace/0x2Hacks.github.io/candy-machine-ui/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import _regeneratorRuntime from\"/workspace/0x2Hacks.github.io/candy-machine-ui/node_modules/@babel/runtime/regenerator/index.js\";import{Transaction}from'@solana/web3.js';import{WalletNotConnectedError}from'@solana/wallet-adapter-base';export var DEFAULT_TIMEOUT=60000;export var getErrorForTransaction=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection,txid){var tx,errors;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return connection.confirmTransaction(txid,'max');case 2:_context.next=4;return connection.getParsedConfirmedTransaction(txid);case 4:tx=_context.sent;errors=[];if(tx!==null&&tx!==void 0&&tx.meta&&tx.meta.logMessages){tx.meta.logMessages.forEach(function(log){var regex=/Error: (.*)/gm;var m;while((m=regex.exec(log))!==null){// This is necessary to avoid infinite loops with zero-width matches\nif(m.index===regex.lastIndex){regex.lastIndex++;}if(m.length>1){errors.push(m[1]);}}});}return _context.abrupt(\"return\",errors);case 8:case\"end\":return _context.stop();}}},_callee);}));return function getErrorForTransaction(_x,_x2){return _ref.apply(this,arguments);};}();export var SequenceType;(function(SequenceType){SequenceType[SequenceType[\"Sequential\"]=0]=\"Sequential\";SequenceType[SequenceType[\"Parallel\"]=1]=\"Parallel\";SequenceType[SequenceType[\"StopOnFailure\"]=2]=\"StopOnFailure\";})(SequenceType||(SequenceType={}));export function sendTransactionsWithManualRetry(_x3,_x4,_x5,_x6){return _sendTransactionsWithManualRetry.apply(this,arguments);}function _sendTransactionsWithManualRetry(){_sendTransactionsWithManualRetry=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(connection,wallet,instructions,signers){var stopPoint,tries,lastInstructionsLength,toRemoveSigners,ids,filteredSigners,id,_yield$sendTransactio,txs;return _regeneratorRuntime.wrap(function _callee5$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:stopPoint=0;tries=0;lastInstructionsLength=null;toRemoveSigners={};instructions=instructions.filter(function(instr,i){if(instr.length>0){return true;}else{toRemoveSigners[i]=true;return false;}});ids=[];filteredSigners=signers.filter(function(_,i){return!toRemoveSigners[i];});case 7:if(!(stopPoint<instructions.length&&tries<3)){_context6.next=34;break;}instructions=instructions.slice(stopPoint,instructions.length);filteredSigners=filteredSigners.slice(stopPoint,filteredSigners.length);if(instructions.length===lastInstructionsLength)tries=tries+1;else tries=0;_context6.prev=11;if(!(instructions.length===1)){_context6.next=20;break;}_context6.next=15;return sendTransactionWithRetry(connection,wallet,instructions[0],filteredSigners[0],'single');case 15:id=_context6.sent;ids.push(id.txid);stopPoint=1;_context6.next=25;break;case 20:_context6.next=22;return sendTransactions(connection,wallet,instructions,filteredSigners,SequenceType.StopOnFailure,'single');case 22:_yield$sendTransactio=_context6.sent;txs=_yield$sendTransactio.txs;ids=ids.concat(txs.map(function(t){return t.txid;}));case 25:_context6.next=30;break;case 27:_context6.prev=27;_context6.t0=_context6[\"catch\"](11);console.error(_context6.t0);case 30:console.log('Died on ',stopPoint,'retrying from instruction',instructions[stopPoint],'instructions length is',instructions.length);lastInstructionsLength=instructions.length;_context6.next=7;break;case 34:return _context6.abrupt(\"return\",ids);case 35:case\"end\":return _context6.stop();}}},_callee5,null,[[11,27]]);}));return _sendTransactionsWithManualRetry.apply(this,arguments);}export var sendTransactions=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connection,wallet,instructionSet,signersSet){var sequenceType,commitment,successCallback,failCallback,block,beforeTransactions,afterTransactions,unsignedTxns,_loop,i,_ret,partiallySignedTransactions,fullySignedTransactions,signedTxns,pendingTxns,_loop2,_i,_ret2,result,_args3=arguments;return _regeneratorRuntime.wrap(function _callee2$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:sequenceType=_args3.length>4&&_args3[4]!==undefined?_args3[4]:SequenceType.Parallel;commitment=_args3.length>5&&_args3[5]!==undefined?_args3[5]:'singleGossip';successCallback=_args3.length>6&&_args3[6]!==undefined?_args3[6]:function(txid,ind){};failCallback=_args3.length>7&&_args3[7]!==undefined?_args3[7]:function(txid,ind){return false;};block=_args3.length>8?_args3[8]:undefined;beforeTransactions=_args3.length>9&&_args3[9]!==undefined?_args3[9]:[];afterTransactions=_args3.length>10&&_args3[10]!==undefined?_args3[10]:[];if(wallet.publicKey){_context3.next=9;break;}throw new WalletNotConnectedError();case 9:unsignedTxns=beforeTransactions;if(block){_context3.next=14;break;}_context3.next=13;return connection.getRecentBlockhash(commitment);case 13:block=_context3.sent;case 14:_loop=function _loop(i){var instructions=instructionSet[i];var signers=signersSet[i];if(instructions.length===0){return\"continue\";}var transaction=new Transaction();instructions.forEach(function(instruction){return transaction.add(instruction);});transaction.recentBlockhash=block.blockhash;transaction.setSigners.apply(transaction,[// fee payed by the wallet owner\nwallet.publicKey].concat(_toConsumableArray(signers.map(function(s){return s.publicKey;}))));if(signers.length>0){transaction.partialSign.apply(transaction,_toConsumableArray(signers));}unsignedTxns.push(transaction);};i=0;case 16:if(!(i<instructionSet.length)){_context3.next=23;break;}_ret=_loop(i);if(!(_ret===\"continue\")){_context3.next=20;break;}return _context3.abrupt(\"continue\",20);case 20:i++;_context3.next=16;break;case 23:unsignedTxns.push.apply(unsignedTxns,_toConsumableArray(afterTransactions));partiallySignedTransactions=unsignedTxns.filter(function(t){return t.signatures.find(function(sig){return sig.publicKey.equals(wallet.publicKey);});});fullySignedTransactions=unsignedTxns.filter(function(t){return!t.signatures.find(function(sig){return sig.publicKey.equals(wallet.publicKey);});});_context3.next=28;return wallet.signAllTransactions(partiallySignedTransactions);case 28:signedTxns=_context3.sent;signedTxns=fullySignedTransactions.concat(signedTxns);pendingTxns=[];console.log('Signed txns length',signedTxns.length,'vs handed in length',instructionSet.length);_loop2=/*#__PURE__*/_regeneratorRuntime.mark(function _loop2(_i){var signedTxnPromise;return _regeneratorRuntime.wrap(function _loop2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:signedTxnPromise=sendSignedTransaction({connection:connection,signedTransaction:signedTxns[_i]});if(!(sequenceType!==SequenceType.Parallel)){_context2.next=22;break;}_context2.prev=2;_context2.next=5;return signedTxnPromise.then(function(_ref3){var txid=_ref3.txid,slot=_ref3.slot;return successCallback(txid,_i);});case 5:pendingTxns.push(signedTxnPromise);_context2.next=20;break;case 8:_context2.prev=8;_context2.t0=_context2[\"catch\"](2);console.log('Failed at txn index:',_i);console.log('Caught failure:',_context2.t0);failCallback(signedTxns[_i],_i);if(!(sequenceType===SequenceType.StopOnFailure)){_context2.next=20;break;}_context2.t1=_i;_context2.next=17;return Promise.all(pendingTxns);case 17:_context2.t2=_context2.sent;_context2.t3={number:_context2.t1,txs:_context2.t2};return _context2.abrupt(\"return\",{v:_context2.t3});case 20:_context2.next=23;break;case 22:pendingTxns.push(signedTxnPromise);case 23:case\"end\":return _context2.stop();}}},_loop2,null,[[2,8]]);});_i=0;case 34:if(!(_i<signedTxns.length)){_context3.next=42;break;}return _context3.delegateYield(_loop2(_i),\"t0\",36);case 36:_ret2=_context3.t0;if(!(typeof _ret2===\"object\")){_context3.next=39;break;}return _context3.abrupt(\"return\",_ret2.v);case 39:_i++;_context3.next=34;break;case 42:if(!(sequenceType!==SequenceType.Parallel)){_context3.next=47;break;}_context3.next=45;return Promise.all(pendingTxns);case 45:result=_context3.sent;return _context3.abrupt(\"return\",{number:signedTxns.length,txs:result});case 47:_context3.t1=signedTxns.length;_context3.next=50;return Promise.all(pendingTxns);case 50:_context3.t2=_context3.sent;return _context3.abrupt(\"return\",{number:_context3.t1,txs:_context3.t2});case 52:case\"end\":return _context3.stop();}}},_callee2);}));return function sendTransactions(_x7,_x8,_x9,_x10){return _ref2.apply(this,arguments);};}();export var sendTransaction=/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(connection,wallet,instructions,signers){var awaitConfirmation,commitment,includesFeePayer,block,transaction,_transaction,_transaction2,_transaction3,rawTransaction,options,txid,slot,confirmation,errors,_args4=arguments;return _regeneratorRuntime.wrap(function _callee3$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:awaitConfirmation=_args4.length>4&&_args4[4]!==undefined?_args4[4]:true;commitment=_args4.length>5&&_args4[5]!==undefined?_args4[5]:'singleGossip';includesFeePayer=_args4.length>6&&_args4[6]!==undefined?_args4[6]:false;block=_args4.length>7?_args4[7]:undefined;if(wallet.publicKey){_context4.next=6;break;}throw new WalletNotConnectedError();case 6:if(!(instructions instanceof Transaction)){_context4.next=10;break;}transaction=instructions;_context4.next=24;break;case 10:transaction=new Transaction();instructions.forEach(function(instruction){return transaction.add(instruction);});_context4.t0=block;if(_context4.t0){_context4.next=17;break;}_context4.next=16;return connection.getRecentBlockhash(commitment);case 16:_context4.t0=_context4.sent;case 17:transaction.recentBlockhash=_context4.t0.blockhash;if(includesFeePayer){(_transaction=transaction).setSigners.apply(_transaction,_toConsumableArray(signers.map(function(s){return s.publicKey;})));}else{(_transaction2=transaction).setSigners.apply(_transaction2,[// fee payed by the wallet owner\nwallet.publicKey].concat(_toConsumableArray(signers.map(function(s){return s.publicKey;}))));}if(signers.length>0){(_transaction3=transaction).partialSign.apply(_transaction3,_toConsumableArray(signers));}if(includesFeePayer){_context4.next=24;break;}_context4.next=23;return wallet.signTransaction(transaction);case 23:transaction=_context4.sent;case 24:rawTransaction=transaction.serialize();options={skipPreflight:true,commitment:commitment};_context4.next=28;return connection.sendRawTransaction(rawTransaction,options);case 28:txid=_context4.sent;slot=0;if(!awaitConfirmation){_context4.next=43;break;}_context4.next=33;return awaitTransactionSignatureConfirmation(txid,DEFAULT_TIMEOUT,connection,commitment);case 33:confirmation=_context4.sent;if(confirmation){_context4.next=36;break;}throw new Error('Timed out awaiting confirmation on transaction');case 36:slot=(confirmation===null||confirmation===void 0?void 0:confirmation.slot)||0;if(!(confirmation!==null&&confirmation!==void 0&&confirmation.err)){_context4.next=43;break;}_context4.next=40;return getErrorForTransaction(connection,txid);case 40:errors=_context4.sent;console.log(errors);throw new Error(\"Raw transaction \".concat(txid,\" failed\"));case 43:return _context4.abrupt(\"return\",{txid:txid,slot:slot});case 44:case\"end\":return _context4.stop();}}},_callee3);}));return function sendTransaction(_x11,_x12,_x13,_x14){return _ref4.apply(this,arguments);};}();export var sendTransactionWithRetry=/*#__PURE__*/function(){var _ref5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(connection,wallet,instructions,signers){var commitment,includesFeePayer,block,beforeSend,transaction,_transaction4,_transaction5,_transaction6,_yield$sendSignedTran,txid,slot,_args5=arguments;return _regeneratorRuntime.wrap(function _callee4$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:commitment=_args5.length>4&&_args5[4]!==undefined?_args5[4]:'singleGossip';includesFeePayer=_args5.length>5&&_args5[5]!==undefined?_args5[5]:false;block=_args5.length>6?_args5[6]:undefined;beforeSend=_args5.length>7?_args5[7]:undefined;if(wallet.publicKey){_context5.next=6;break;}throw new WalletNotConnectedError();case 6:transaction=new Transaction();instructions.forEach(function(instruction){return transaction.add(instruction);});_context5.t0=block;if(_context5.t0){_context5.next=13;break;}_context5.next=12;return connection.getRecentBlockhash(commitment);case 12:_context5.t0=_context5.sent;case 13:transaction.recentBlockhash=_context5.t0.blockhash;if(includesFeePayer){(_transaction4=transaction).setSigners.apply(_transaction4,_toConsumableArray(signers.map(function(s){return s.publicKey;})));}else{(_transaction5=transaction).setSigners.apply(_transaction5,[// fee payed by the wallet owner\nwallet.publicKey].concat(_toConsumableArray(signers.map(function(s){return s.publicKey;}))));}if(signers.length>0){(_transaction6=transaction).partialSign.apply(_transaction6,_toConsumableArray(signers));}if(includesFeePayer){_context5.next=20;break;}_context5.next=19;return wallet.signTransaction(transaction);case 19:transaction=_context5.sent;case 20:if(beforeSend){beforeSend();}_context5.next=23;return sendSignedTransaction({connection:connection,signedTransaction:transaction});case 23:_yield$sendSignedTran=_context5.sent;txid=_yield$sendSignedTran.txid;slot=_yield$sendSignedTran.slot;return _context5.abrupt(\"return\",{txid:txid,slot:slot});case 27:case\"end\":return _context5.stop();}}},_callee4);}));return function sendTransactionWithRetry(_x15,_x16,_x17,_x18){return _ref5.apply(this,arguments);};}();export var getUnixTs=function getUnixTs(){return new Date().getTime()/1000;};export function sendSignedTransaction(_x19){return _sendSignedTransaction.apply(this,arguments);}function _sendSignedTransaction(){_sendSignedTransaction=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee7(_ref6){var signedTransaction,connection,_ref6$timeout,timeout,rawTransaction,startTime,slot,txid,done,confirmation,simulateResult,i,line;return _regeneratorRuntime.wrap(function _callee7$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:signedTransaction=_ref6.signedTransaction,connection=_ref6.connection,_ref6$timeout=_ref6.timeout,timeout=_ref6$timeout===void 0?DEFAULT_TIMEOUT:_ref6$timeout;rawTransaction=signedTransaction.serialize();startTime=getUnixTs();slot=0;_context8.next=6;return connection.sendRawTransaction(rawTransaction,{skipPreflight:true});case 6:txid=_context8.sent;console.log('Started awaiting confirmation for',txid);done=false;_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(){return _regeneratorRuntime.wrap(function _callee6$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:if(!(!done&&getUnixTs()-startTime<timeout)){_context7.next=6;break;}connection.sendRawTransaction(rawTransaction,{skipPreflight:true});_context7.next=4;return sleep(500);case 4:_context7.next=0;break;case 6:case\"end\":return _context7.stop();}}},_callee6);}))();_context8.prev=10;_context8.next=13;return awaitTransactionSignatureConfirmation(txid,timeout,connection,'recent',true);case 13:confirmation=_context8.sent;if(confirmation){_context8.next=16;break;}throw new Error('Timed out awaiting confirmation on transaction');case 16:if(!confirmation.err){_context8.next=19;break;}console.error(confirmation.err);throw new Error('Transaction failed: Custom instruction error');case 19:slot=(confirmation===null||confirmation===void 0?void 0:confirmation.slot)||0;_context8.next=47;break;case 22:_context8.prev=22;_context8.t0=_context8[\"catch\"](10);console.error('Timeout Error caught',_context8.t0);if(!_context8.t0.timeout){_context8.next=27;break;}throw new Error('Timed out awaiting confirmation on transaction');case 27:simulateResult=null;_context8.prev=28;_context8.next=31;return simulateTransaction(connection,signedTransaction,'single');case 31:simulateResult=_context8.sent.value;_context8.next=36;break;case 34:_context8.prev=34;_context8.t1=_context8[\"catch\"](28);case 36:if(!(simulateResult&&simulateResult.err)){_context8.next=47;break;}if(!simulateResult.logs){_context8.next=46;break;}i=simulateResult.logs.length-1;case 39:if(!(i>=0)){_context8.next=46;break;}line=simulateResult.logs[i];if(!line.startsWith('Program log: ')){_context8.next=43;break;}throw new Error('Transaction failed: '+line.slice('Program log: '.length));case 43:--i;_context8.next=39;break;case 46:throw new Error(JSON.stringify(simulateResult.err));case 47:_context8.prev=47;done=true;return _context8.finish(47);case 50:console.log('Latency',txid,getUnixTs()-startTime);return _context8.abrupt(\"return\",{txid:txid,slot:slot});case 52:case\"end\":return _context8.stop();}}},_callee7,null,[[10,22,47,50],[28,34]]);}));return _sendSignedTransaction.apply(this,arguments);}function simulateTransaction(_x20,_x21,_x22){return _simulateTransaction.apply(this,arguments);}function _simulateTransaction(){_simulateTransaction=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee8(connection,transaction,commitment){var signData,wireTransaction,encodedTransaction,config,args,res;return _regeneratorRuntime.wrap(function _callee8$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:_context9.next=2;return connection._recentBlockhash(// @ts-ignore\nconnection._disableBlockhashCaching);case 2:transaction.recentBlockhash=_context9.sent;signData=transaction.serializeMessage();// @ts-ignore\nwireTransaction=transaction._serialize(signData);encodedTransaction=wireTransaction.toString('base64');config={encoding:'base64',commitment:commitment};args=[encodedTransaction,config];// @ts-ignore\n_context9.next=10;return connection._rpcRequest('simulateTransaction',args);case 10:res=_context9.sent;if(!res.error){_context9.next=13;break;}throw new Error('failed to simulate transaction: '+res.error.message);case 13:return _context9.abrupt(\"return\",res.result);case 14:case\"end\":return _context9.stop();}}},_callee8);}));return _simulateTransaction.apply(this,arguments);}function awaitTransactionSignatureConfirmation(_x23,_x24,_x25){return _awaitTransactionSignatureConfirmation.apply(this,arguments);}function _awaitTransactionSignatureConfirmation(){_awaitTransactionSignatureConfirmation=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee11(txid,timeout,connection){var commitment,queryStatus,done,status,subId,_args12=arguments;return _regeneratorRuntime.wrap(function _callee11$(_context12){while(1){switch(_context12.prev=_context12.next){case 0:commitment=_args12.length>3&&_args12[3]!==undefined?_args12[3]:'recent';queryStatus=_args12.length>4&&_args12[4]!==undefined?_args12[4]:false;done=false;status={slot:0,confirmations:0,err:null};subId=0;_context12.next=7;return new Promise(/*#__PURE__*/function(){var _ref8=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee10(resolve,reject){return _regeneratorRuntime.wrap(function _callee10$(_context11){while(1){switch(_context11.prev=_context11.next){case 0:setTimeout(function(){if(done){return;}done=true;console.log('Rejecting for timeout...');reject({timeout:true});},timeout);try{subId=connection.onSignature(txid,function(result,context){done=true;status={err:result.err,slot:context.slot,confirmations:0};if(result.err){console.log('Rejected via websocket',result.err);reject(status);}else{console.log('Resolved via websocket',result);resolve(status);}},commitment);}catch(e){done=true;console.error('WS error in setup',txid,e);}case 2:if(!(!done&&queryStatus)){_context11.next=8;break;}// eslint-disable-next-line no-loop-func\n_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee9(){var signatureStatuses;return _regeneratorRuntime.wrap(function _callee9$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:_context10.prev=0;_context10.next=3;return connection.getSignatureStatuses([txid]);case 3:signatureStatuses=_context10.sent;status=signatureStatuses&&signatureStatuses.value[0];if(!done){if(!status){console.log('REST null result for',txid,status);}else if(status.err){console.log('REST error for',txid,status);done=true;reject(status.err);}else if(!status.confirmations){console.log('REST no confirmations for',txid,status);}else{console.log('REST confirmation for',txid,status);done=true;resolve(status);}}_context10.next=11;break;case 8:_context10.prev=8;_context10.t0=_context10[\"catch\"](0);if(!done){console.log('REST connection error: txid',txid,_context10.t0);}case 11:case\"end\":return _context10.stop();}}},_callee9,null,[[0,8]]);}))();_context11.next=6;return sleep(2000);case 6:_context11.next=2;break;case 8:case\"end\":return _context11.stop();}}},_callee10);}));return function(_x26,_x27){return _ref8.apply(this,arguments);};}());case 7:status=_context12.sent;//@ts-ignore\nif(connection._signatureSubscriptions[subId])connection.removeSignatureListener(subId);done=true;console.log('Returning status',status);return _context12.abrupt(\"return\",status);case 12:case\"end\":return _context12.stop();}}},_callee11);}));return _awaitTransactionSignatureConfirmation.apply(this,arguments);}export function sleep(ms){return new Promise(function(resolve){return setTimeout(resolve,ms);});}","map":{"version":3,"sources":["/workspace/0x2Hacks.github.io/candy-machine-ui/src/connection.tsx"],"names":["Transaction","WalletNotConnectedError","DEFAULT_TIMEOUT","getErrorForTransaction","connection","txid","confirmTransaction","getParsedConfirmedTransaction","tx","errors","meta","logMessages","forEach","log","regex","m","exec","index","lastIndex","length","push","SequenceType","sendTransactionsWithManualRetry","wallet","instructions","signers","stopPoint","tries","lastInstructionsLength","toRemoveSigners","filter","instr","i","ids","filteredSigners","_","slice","sendTransactionWithRetry","id","sendTransactions","StopOnFailure","txs","concat","map","t","console","error","instructionSet","signersSet","sequenceType","Parallel","commitment","successCallback","ind","failCallback","block","beforeTransactions","afterTransactions","publicKey","unsignedTxns","getRecentBlockhash","transaction","instruction","add","recentBlockhash","blockhash","setSigners","s","partialSign","partiallySignedTransactions","signatures","find","sig","equals","fullySignedTransactions","signAllTransactions","signedTxns","pendingTxns","signedTxnPromise","sendSignedTransaction","signedTransaction","then","slot","Promise","all","number","result","sendTransaction","awaitConfirmation","includesFeePayer","signTransaction","rawTransaction","serialize","options","skipPreflight","sendRawTransaction","awaitTransactionSignatureConfirmation","confirmation","Error","err","beforeSend","getUnixTs","Date","getTime","timeout","startTime","done","sleep","simulateResult","simulateTransaction","value","logs","line","startsWith","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","config","encoding","args","_rpcRequest","res","message","queryStatus","status","confirmations","subId","resolve","reject","setTimeout","onSignature","context","e","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener","ms"],"mappings":"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","sourcesContent":["import {\n  Keypair,\n  Commitment,\n  Connection,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n  Blockhash,\n  FeeCalculator,\n} from '@solana/web3.js';\n\nimport { WalletNotConnectedError } from '@solana/wallet-adapter-base';\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport const DEFAULT_TIMEOUT = 60000;\n\nexport const getErrorForTransaction = async (\n  connection: Connection,\n  txid: string,\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, 'max');\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport async function sendTransactionsWithManualRetry(\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[][],\n  signers: Keypair[][],\n): Promise<(string | undefined)[]> {\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength = null;\n  let toRemoveSigners: Record<number, boolean> = {};\n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let ids: string[] = [];\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\n    else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        const id = await sendTransactionWithRetry(\n          connection,\n          wallet,\n          instructions[0],\n          filteredSigners[0],\n          'single',\n        );\n        ids.push(id.txid);\n        stopPoint = 1;\n      } else {\n        const { txs } = await sendTransactions(\n          connection,\n          wallet,\n          instructions,\n          filteredSigners,\n          SequenceType.StopOnFailure,\n          'single',\n        );\n        ids = ids.concat(txs.map(t => t.txid));\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    console.log(\n      'Died on ',\n      stopPoint,\n      'retrying from instruction',\n      instructions[stopPoint],\n      'instructions length is',\n      instructions.length,\n    );\n    lastInstructionsLength = instructions.length;\n  }\n\n  return ids;\n}\n\nexport const sendTransactions = async (\n  connection: Connection,\n  wallet: any,\n  instructionSet: TransactionInstruction[][],\n  signersSet: Keypair[][],\n  sequenceType: SequenceType = SequenceType.Parallel,\n  commitment: Commitment = 'singleGossip',\n  successCallback: (txid: string, ind: number) => void = (txid, ind) => {},\n  failCallback: (reason: string, ind: number) => boolean = (txid, ind) => false,\n  block?: BlockhashAndFeeCalculator,\n  beforeTransactions: Transaction[] = [],\n  afterTransactions: Transaction[] = [],\n): Promise<{ number: number; txs: { txid: string; slot: number }[] }> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  const unsignedTxns: Transaction[] = beforeTransactions;\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n  unsignedTxns.push(...afterTransactions);\n\n  const partiallySignedTransactions = unsignedTxns.filter(t =>\n    t.signatures.find(sig => sig.publicKey.equals(wallet.publicKey)),\n  );\n  const fullySignedTransactions = unsignedTxns.filter(\n    t => !t.signatures.find(sig => sig.publicKey.equals(wallet.publicKey)),\n  );\n  let signedTxns = await wallet.signAllTransactions(\n    partiallySignedTransactions,\n  );\n  signedTxns = fullySignedTransactions.concat(signedTxns);\n  const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\n\n  console.log(\n    'Signed txns length',\n    signedTxns.length,\n    'vs handed in length',\n    instructionSet.length,\n  );\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i],\n    });\n\n    if (sequenceType !== SequenceType.Parallel) {\n      try {\n        await signedTxnPromise.then(({ txid, slot }) =>\n          successCallback(txid, i),\n        );\n        pendingTxns.push(signedTxnPromise);\n      } catch (e) {\n        console.log('Failed at txn index:', i);\n        console.log('Caught failure:', e);\n\n        failCallback(signedTxns[i], i);\n        if (sequenceType === SequenceType.StopOnFailure) {\n          return {\n            number: i,\n            txs: await Promise.all(pendingTxns),\n          };\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== SequenceType.Parallel) {\n    const result = await Promise.all(pendingTxns);\n    return { number: signedTxns.length, txs: result };\n  }\n\n  return { number: signedTxns.length, txs: await Promise.all(pendingTxns) };\n};\n\nexport const sendTransaction = async (\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[] | Transaction,\n  signers: Keypair[],\n  awaitConfirmation = true,\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction: Transaction;\n  if (instructions instanceof Transaction) {\n    transaction = instructions;\n  } else {\n    transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = (\n      block || (await connection.getRecentBlockhash(commitment))\n    ).blockhash;\n\n    if (includesFeePayer) {\n      transaction.setSigners(...signers.map(s => s.publicKey));\n    } else {\n      transaction.setSigners(\n        // fee payed by the wallet owner\n        wallet.publicKey,\n        ...signers.map(s => s.publicKey),\n      );\n    }\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n    if (!includesFeePayer) {\n      transaction = await wallet.signTransaction(transaction);\n    }\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment,\n  };\n\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      DEFAULT_TIMEOUT,\n      connection,\n      commitment,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n    slot = confirmation?.slot || 0;\n\n    if (confirmation?.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n\n      console.log(errors);\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return { txid, slot };\n};\n\nexport const sendTransactionWithRetry = async (\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const { txid, slot } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction,\n  });\n\n  return { txid, slot };\n};\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    },\n  );\n\n  console.log('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      'recent',\n      true,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err: any) {\n    console.error('Timeout Error caught', err);\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {}\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n              'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment,\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config: any = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n  commitment: Commitment = 'recent',\n  queryStatus = false,\n): Promise<SignatureStatus | null | void> {\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log('Rejected via websocket', result.err);\n            reject(status);\n          } else {\n            console.log('Resolved via websocket', result);\n            resolve(status);\n          }\n        },\n        commitment,\n      );\n    } catch (e) {\n      done = true;\n      console.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  console.log('Returning status', status);\n  return status;\n}\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n"]},"metadata":{},"sourceType":"module"}