{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.featureExists = exports.getFeatureAccountAddress = exports.gatekeeperExists = exports.getGatewayToken = exports.removeAccountChangeListener = exports.onGatewayTokenChange = exports.findGatewayToken = exports.findGatewayTokens = exports.dataToGatewayToken = exports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork = exports.getGatekeeperAccountAddress = void 0;\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst constants_1 = require(\"./constants\");\n\nconst types_1 = require(\"../types\");\n\nconst GatewayTokenData_1 = require(\"./GatewayTokenData\");\n\nconst GatewayNetworkData_1 = require(\"./GatewayNetworkData\");\n/**\n * Derive the address of the gatekeeper PDA for this gatekeeper\n * @param authority The gatekeeper\n * @param network The network\n */\n\n\nconst getGatekeeperAccountAddress = (authority, network) => __awaiter(void 0, void 0, void 0, function* () {\n  const publicKeyNonce = yield web3_js_1.PublicKey.findProgramAddress([authority.toBuffer(), network.toBuffer(), Buffer.from(constants_1.GATEKEEPER_NONCE_SEED_STRING, \"utf8\")], constants_1.PROGRAM_ID);\n  return publicKeyNonce[0];\n});\n\nexports.getGatekeeperAccountAddress = getGatekeeperAccountAddress;\n/**\n * Derive the address of the gateway token PDA for this owner address and optional seed.\n * @param owner The owner of the gateway token\n * @param gatekeeperNetwork The network of the gateway token\n * @param seed An 8-byte seed array, used to add multiple tokens to the same owner. Must be unique to each token, if present\n */\n\nconst getGatewayTokenAddressForOwnerAndGatekeeperNetwork = (owner, gatekeeperNetwork, seed) => __awaiter(void 0, void 0, void 0, function* () {\n  const additionalSeed = seed ? Buffer.from(seed) : Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]);\n\n  if (additionalSeed.length != 8) {\n    throw new Error(\"Additional Seed has length \" + additionalSeed.length + \" instead of 8 when calling getGatewayTokenAddressForOwnerAndGatekeeperNetwork.\");\n  }\n\n  const seeds = [owner.toBuffer(), Buffer.from(constants_1.GATEWAY_TOKEN_ADDRESS_SEED, \"utf8\"), additionalSeed, gatekeeperNetwork.toBuffer()];\n  const publicKeyNonce = yield web3_js_1.PublicKey.findProgramAddress(seeds, constants_1.PROGRAM_ID);\n  return publicKeyNonce[0];\n});\n\nexports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork = getGatewayTokenAddressForOwnerAndGatekeeperNetwork; // Based on solana/integration-lib/src/state.rs\n// If the optional the parent-gateway-token field is populated, this value will be\n// 34 (2 + 32) instead. TODO IDCOM-320 restructure the gateway token accounts to put\n// all optional values at the end of the struct to simplify account parsing a little\n\nconst GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET = 2; // As above, if optional fields are present, this will differ. TODO IDCOM-320 fixes this\n\nconst GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET = 35;\n\nfunction fromGatewayTokenState(state) {\n  if (!!state.active) return types_1.State.ACTIVE;\n  if (!!state.revoked) return types_1.State.REVOKED;\n  if (!!state.frozen) return types_1.State.FROZEN;\n  throw new Error(\"Unrecognised state \" + JSON.stringify(state));\n}\n\nconst dataToGatewayToken = (data, publicKey) => {\n  var _a;\n\n  return new types_1.GatewayToken(data.issuingGatekeeper.toPublicKey(), data.gatekeeperNetwork.toPublicKey(), data.owner.toPublicKey(), fromGatewayTokenState(data.state), publicKey, constants_1.PROGRAM_ID, (_a = data.expiry) === null || _a === void 0 ? void 0 : _a.toNumber());\n};\n\nexports.dataToGatewayToken = dataToGatewayToken;\n/**\n * Find all gateway tokens for a user on a gatekeeper network, optionally filtering out revoked tokens.\n *\n * Warning - this uses the Solana getProgramAccounts RPC endpoint, which is inefficient and may be\n * blocked by some RPC services.\n *\n * @param connection A solana connection object\n * @param owner The token owner\n * @param gatekeeperNetwork The network to find a token for\n * @param {boolean=false} includeRevoked If false (default), filter out revoked tokens\n * @returns {Promise<GatewayToken[]>} All tokens for the owner\n */\n\nconst findGatewayTokens = function (connection, owner, gatekeeperNetwork) {\n  let includeRevoked = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const ownerFilter = {\n      memcmp: {\n        offset: GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET,\n        bytes: owner.toBase58()\n      }\n    };\n    const gatekeeperNetworkFilter = {\n      memcmp: {\n        offset: GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET,\n        bytes: gatekeeperNetwork === null || gatekeeperNetwork === void 0 ? void 0 : gatekeeperNetwork.toBase58()\n      }\n    };\n    const filters = [ownerFilter, gatekeeperNetworkFilter];\n    const accountsResponse = yield connection.getProgramAccounts(constants_1.PROGRAM_ID, {\n      filters\n    });\n    if (!accountsResponse) return [];\n\n    const toGatewayToken = _ref => {\n      let {\n        pubkey,\n        account\n      } = _ref;\n      return (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), pubkey);\n    };\n\n    return accountsResponse.map(toGatewayToken).filter(gatewayToken => gatewayToken.state !== types_1.State.REVOKED || includeRevoked);\n  });\n};\n\nexports.findGatewayTokens = findGatewayTokens;\n/**\n * Get a gateway token for the owner and network, if it exists.\n * @param connection A solana connection object\n * @param owner The token owner\n * @param gatekeeperNetwork The network to find a token for\n * @returns Promise<GatewayToken | null> An unrevoked token, if one exists for the owner\n */\n\nconst findGatewayToken = (connection, owner, gatekeeperNetwork) => __awaiter(void 0, void 0, void 0, function* () {\n  const gatewayTokenAddress = yield (0, exports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork)(owner, gatekeeperNetwork);\n  const account = yield connection.getAccountInfo(gatewayTokenAddress, constants_1.SOLANA_COMMITMENT);\n  if (!account) return null;\n  return (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), gatewayTokenAddress);\n});\n\nexports.findGatewayToken = findGatewayToken;\n/**\n * Register a callback to be called whenever a gateway token changes state\n * @param connection A solana connection object\n * @param gatewayTokenAddress The address of the gateway token\n * @param callback The callback to register\n * @param commitment The solana commitment level at which to register gateway token changes. Defaults to 'confirmed'\n * @return The subscription id\n */\n\nconst onGatewayTokenChange = function (connection, gatewayTokenAddress, callback) {\n  let commitment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_1.SOLANA_COMMITMENT;\n\n  const accountCallback = accountInfo => {\n    const gatewayToken = (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(accountInfo.data), gatewayTokenAddress);\n    callback(gatewayToken);\n  };\n\n  return connection.onAccountChange(gatewayTokenAddress, accountCallback, commitment);\n};\n\nexports.onGatewayTokenChange = onGatewayTokenChange;\n/**\n * Stops listening to gateway state changes\n * @param connection A solana connection object\n * @param id The subscription id to deregister\n */\n\nconst removeAccountChangeListener = (connection, id) => connection.removeAccountChangeListener(id);\n\nexports.removeAccountChangeListener = removeAccountChangeListener;\n/**\n * Lookup the gateway token at a given address\n * @param connection A solana connection object\n * @param gatewayTokenAddress The address of the gateway token\n */\n\nconst getGatewayToken = (connection, gatewayTokenAddress) => __awaiter(void 0, void 0, void 0, function* () {\n  const account = yield connection.getAccountInfo(gatewayTokenAddress, constants_1.SOLANA_COMMITMENT);\n  if (!account) return null;\n  return (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), gatewayTokenAddress);\n});\n\nexports.getGatewayToken = getGatewayToken;\n/**\n * Returns whether or not a gatekeeper exists from a network and authority\n * @param connection A solana connection\n * @param gatekeeperAuthority The authority of the gatekeeper\n * @param gatekeeperNetwork The network of the gatekeeper\n */\n\nconst gatekeeperExists = (connection, gatekeeperAuthority, gatekeeperNetwork) => __awaiter(void 0, void 0, void 0, function* () {\n  const gatekeeperAccount = yield (0, exports.getGatekeeperAccountAddress)(gatekeeperAuthority, gatekeeperNetwork);\n  const account = yield connection.getAccountInfo(gatekeeperAccount, constants_1.SOLANA_COMMITMENT);\n  return account != null && constants_1.PROGRAM_ID.equals(account.owner);\n});\n\nexports.gatekeeperExists = gatekeeperExists;\n/**\n * Derive the address of the feature PDA\n * @param featureName The name of the feature to set.\n * @param network The network\n */\n\nconst getFeatureAccountAddress = (feature, network) => __awaiter(void 0, void 0, void 0, function* () {\n  const featureName = (0, GatewayNetworkData_1.mapEnumToFeatureName)(feature.enum);\n  const publicKeyNonce = yield web3_js_1.PublicKey.findProgramAddress([network.toBytes(), Buffer.from(featureName, \"utf8\")], constants_1.PROGRAM_ID);\n  return publicKeyNonce[0];\n});\n\nexports.getFeatureAccountAddress = getFeatureAccountAddress;\n/**\n * Return true if an address feature exists.\n * @param featureName The name of the feature to set.\n * @param network The network\n */\n\nconst featureExists = (connection, feature, network) => __awaiter(void 0, void 0, void 0, function* () {\n  const featureAccountAddress = yield (0, exports.getFeatureAccountAddress)(feature, network);\n  const account = yield connection.getAccountInfo(featureAccountAddress, constants_1.SOLANA_COMMITMENT);\n  return account != null && constants_1.PROGRAM_ID.equals(account.owner);\n});\n\nexports.featureExists = featureExists;","map":{"version":3,"sources":["../../src/lib/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.featureExists = exports.getFeatureAccountAddress = exports.gatekeeperExists = exports.getGatewayToken = exports.removeAccountChangeListener = exports.onGatewayTokenChange = exports.findGatewayToken = exports.findGatewayTokens = exports.dataToGatewayToken = exports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork = exports.getGatekeeperAccountAddress = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst constants_1 = require(\"./constants\");\nconst types_1 = require(\"../types\");\nconst GatewayTokenData_1 = require(\"./GatewayTokenData\");\nconst GatewayNetworkData_1 = require(\"./GatewayNetworkData\");\n/**\n * Derive the address of the gatekeeper PDA for this gatekeeper\n * @param authority The gatekeeper\n * @param network The network\n */\nconst getGatekeeperAccountAddress = (authority, network) => __awaiter(void 0, void 0, void 0, function* () {\n    const publicKeyNonce = yield web3_js_1.PublicKey.findProgramAddress([\n        authority.toBuffer(),\n        network.toBuffer(),\n        Buffer.from(constants_1.GATEKEEPER_NONCE_SEED_STRING, \"utf8\"),\n    ], constants_1.PROGRAM_ID);\n    return publicKeyNonce[0];\n});\nexports.getGatekeeperAccountAddress = getGatekeeperAccountAddress;\n/**\n * Derive the address of the gateway token PDA for this owner address and optional seed.\n * @param owner The owner of the gateway token\n * @param gatekeeperNetwork The network of the gateway token\n * @param seed An 8-byte seed array, used to add multiple tokens to the same owner. Must be unique to each token, if present\n */\nconst getGatewayTokenAddressForOwnerAndGatekeeperNetwork = (owner, gatekeeperNetwork, seed) => __awaiter(void 0, void 0, void 0, function* () {\n    const additionalSeed = seed\n        ? Buffer.from(seed)\n        : Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]);\n    if (additionalSeed.length != 8) {\n        throw new Error(\"Additional Seed has length \" +\n            additionalSeed.length +\n            \" instead of 8 when calling getGatewayTokenAddressForOwnerAndGatekeeperNetwork.\");\n    }\n    const seeds = [\n        owner.toBuffer(),\n        Buffer.from(constants_1.GATEWAY_TOKEN_ADDRESS_SEED, \"utf8\"),\n        additionalSeed,\n        gatekeeperNetwork.toBuffer(),\n    ];\n    const publicKeyNonce = yield web3_js_1.PublicKey.findProgramAddress(seeds, constants_1.PROGRAM_ID);\n    return publicKeyNonce[0];\n});\nexports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork = getGatewayTokenAddressForOwnerAndGatekeeperNetwork;\n// Based on solana/integration-lib/src/state.rs\n// If the optional the parent-gateway-token field is populated, this value will be\n// 34 (2 + 32) instead. TODO IDCOM-320 restructure the gateway token accounts to put\n// all optional values at the end of the struct to simplify account parsing a little\nconst GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET = 2;\n// As above, if optional fields are present, this will differ. TODO IDCOM-320 fixes this\nconst GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET = 35;\nfunction fromGatewayTokenState(state) {\n    if (!!state.active)\n        return types_1.State.ACTIVE;\n    if (!!state.revoked)\n        return types_1.State.REVOKED;\n    if (!!state.frozen)\n        return types_1.State.FROZEN;\n    throw new Error(\"Unrecognised state \" + JSON.stringify(state));\n}\nconst dataToGatewayToken = (data, publicKey) => {\n    var _a;\n    return new types_1.GatewayToken(data.issuingGatekeeper.toPublicKey(), data.gatekeeperNetwork.toPublicKey(), data.owner.toPublicKey(), fromGatewayTokenState(data.state), publicKey, constants_1.PROGRAM_ID, (_a = data.expiry) === null || _a === void 0 ? void 0 : _a.toNumber());\n};\nexports.dataToGatewayToken = dataToGatewayToken;\n/**\n * Find all gateway tokens for a user on a gatekeeper network, optionally filtering out revoked tokens.\n *\n * Warning - this uses the Solana getProgramAccounts RPC endpoint, which is inefficient and may be\n * blocked by some RPC services.\n *\n * @param connection A solana connection object\n * @param owner The token owner\n * @param gatekeeperNetwork The network to find a token for\n * @param {boolean=false} includeRevoked If false (default), filter out revoked tokens\n * @returns {Promise<GatewayToken[]>} All tokens for the owner\n */\nconst findGatewayTokens = (connection, owner, gatekeeperNetwork, includeRevoked = false) => __awaiter(void 0, void 0, void 0, function* () {\n    const ownerFilter = {\n        memcmp: {\n            offset: GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET,\n            bytes: owner.toBase58(),\n        },\n    };\n    const gatekeeperNetworkFilter = {\n        memcmp: {\n            offset: GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET,\n            bytes: gatekeeperNetwork === null || gatekeeperNetwork === void 0 ? void 0 : gatekeeperNetwork.toBase58(),\n        },\n    };\n    const filters = [ownerFilter, gatekeeperNetworkFilter];\n    const accountsResponse = yield connection.getProgramAccounts(constants_1.PROGRAM_ID, {\n        filters,\n    });\n    if (!accountsResponse)\n        return [];\n    const toGatewayToken = ({ pubkey, account, }) => (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), pubkey);\n    return accountsResponse\n        .map(toGatewayToken)\n        .filter((gatewayToken) => gatewayToken.state !== types_1.State.REVOKED || includeRevoked);\n});\nexports.findGatewayTokens = findGatewayTokens;\n/**\n * Get a gateway token for the owner and network, if it exists.\n * @param connection A solana connection object\n * @param owner The token owner\n * @param gatekeeperNetwork The network to find a token for\n * @returns Promise<GatewayToken | null> An unrevoked token, if one exists for the owner\n */\nconst findGatewayToken = (connection, owner, gatekeeperNetwork) => __awaiter(void 0, void 0, void 0, function* () {\n    const gatewayTokenAddress = yield (0, exports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork)(owner, gatekeeperNetwork);\n    const account = yield connection.getAccountInfo(gatewayTokenAddress, constants_1.SOLANA_COMMITMENT);\n    if (!account)\n        return null;\n    return (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), gatewayTokenAddress);\n});\nexports.findGatewayToken = findGatewayToken;\n/**\n * Register a callback to be called whenever a gateway token changes state\n * @param connection A solana connection object\n * @param gatewayTokenAddress The address of the gateway token\n * @param callback The callback to register\n * @param commitment The solana commitment level at which to register gateway token changes. Defaults to 'confirmed'\n * @return The subscription id\n */\nconst onGatewayTokenChange = (connection, gatewayTokenAddress, callback, commitment = constants_1.SOLANA_COMMITMENT) => {\n    const accountCallback = (accountInfo) => {\n        const gatewayToken = (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(accountInfo.data), gatewayTokenAddress);\n        callback(gatewayToken);\n    };\n    return connection.onAccountChange(gatewayTokenAddress, accountCallback, commitment);\n};\nexports.onGatewayTokenChange = onGatewayTokenChange;\n/**\n * Stops listening to gateway state changes\n * @param connection A solana connection object\n * @param id The subscription id to deregister\n */\nconst removeAccountChangeListener = (connection, id) => connection.removeAccountChangeListener(id);\nexports.removeAccountChangeListener = removeAccountChangeListener;\n/**\n * Lookup the gateway token at a given address\n * @param connection A solana connection object\n * @param gatewayTokenAddress The address of the gateway token\n */\nconst getGatewayToken = (connection, gatewayTokenAddress) => __awaiter(void 0, void 0, void 0, function* () {\n    const account = yield connection.getAccountInfo(gatewayTokenAddress, constants_1.SOLANA_COMMITMENT);\n    if (!account)\n        return null;\n    return (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), gatewayTokenAddress);\n});\nexports.getGatewayToken = getGatewayToken;\n/**\n * Returns whether or not a gatekeeper exists from a network and authority\n * @param connection A solana connection\n * @param gatekeeperAuthority The authority of the gatekeeper\n * @param gatekeeperNetwork The network of the gatekeeper\n */\nconst gatekeeperExists = (connection, gatekeeperAuthority, gatekeeperNetwork) => __awaiter(void 0, void 0, void 0, function* () {\n    const gatekeeperAccount = yield (0, exports.getGatekeeperAccountAddress)(gatekeeperAuthority, gatekeeperNetwork);\n    const account = yield connection.getAccountInfo(gatekeeperAccount, constants_1.SOLANA_COMMITMENT);\n    return account != null && constants_1.PROGRAM_ID.equals(account.owner);\n});\nexports.gatekeeperExists = gatekeeperExists;\n/**\n * Derive the address of the feature PDA\n * @param featureName The name of the feature to set.\n * @param network The network\n */\nconst getFeatureAccountAddress = (feature, network) => __awaiter(void 0, void 0, void 0, function* () {\n    const featureName = (0, GatewayNetworkData_1.mapEnumToFeatureName)(feature.enum);\n    const publicKeyNonce = yield web3_js_1.PublicKey.findProgramAddress([network.toBytes(), Buffer.from(featureName, \"utf8\")], constants_1.PROGRAM_ID);\n    return publicKeyNonce[0];\n});\nexports.getFeatureAccountAddress = getFeatureAccountAddress;\n/**\n * Return true if an address feature exists.\n * @param featureName The name of the feature to set.\n * @param network The network\n */\nconst featureExists = (connection, feature, network) => __awaiter(void 0, void 0, void 0, function* () {\n    const featureAccountAddress = yield (0, exports.getFeatureAccountAddress)(feature, network);\n    const account = yield connection.getAccountInfo(featureAccountAddress, constants_1.SOLANA_COMMITMENT);\n    return account != null && constants_1.PROGRAM_ID.equals(account.owner);\n});\nexports.featureExists = featureExists;\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"script"}