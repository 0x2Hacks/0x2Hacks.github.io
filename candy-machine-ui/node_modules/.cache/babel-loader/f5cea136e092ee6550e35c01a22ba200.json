{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/workspace/0x2Hacks.github.io/candy-machine-ui/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _asyncToGenerator = require(\"/workspace/0x2Hacks.github.io/candy-machine-ui/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reducer = void 0;\n\nvar react_1 = require(\"react\");\n\nvar utils_1 = require(\"../useReducer/utils\");\n\nvar logger_1 = __importDefault(require(\"../logger\"));\n\nvar types_1 = require(\"../types\");\n\nvar tokenUtils_1 = require(\"../utils/tokenUtils\");\n\nvar reducer = function reducer(state, action) {\n  switch (action.type) {\n    case 'refresh_start':\n      {\n        return Object.assign(Object.assign({}, state), {\n          walletPowoInProgress: false,\n          powoFinished: false,\n          powoRequested: undefined,\n          refreshInProgress: true,\n          gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED\n        });\n      }\n\n    case 'refresh_status_check':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS\n        });\n      }\n\n    case 'refresh_complete':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.COMPLETED,\n          gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken),\n          refreshTimeoutId: undefined,\n          civicPass: Object.assign(Object.assign({}, state.civicPass), {\n            responsePayload: undefined\n          })\n        });\n      }\n\n    case 'refresh_failed':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.FAILED,\n          gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken),\n          civicPass: Object.assign(Object.assign({}, state.civicPass), {\n            responsePayload: undefined\n          })\n        });\n      }\n\n    case 'refresh_with_powo_in_progress':\n      {\n        return Object.assign(Object.assign({}, state), {\n          renderIframe: false,\n          iframeMinimized: true,\n          gatewayStatus: types_1.GatewayStatus.CHECKING\n        });\n      }\n\n    case 'refresh_clear_timeout':\n      return Object.assign(Object.assign({}, state), {\n        refreshTimeoutId: undefined\n      });\n\n    case 'refresh_set_timeout':\n      return Object.assign(Object.assign({}, state), {\n        refreshTimeoutId: action.refreshTimeoutId\n      });\n\n    case 'refresh_token_success':\n      return Object.assign(Object.assign({}, state), {\n        refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN\n      });\n\n    default:\n      return state;\n  }\n};\n\nexports.reducer = reducer;\n\nvar useRefresh = function useRefresh(_ref, state, dispatch) {\n  var stage = _ref.stage,\n      gatekeeperClient = _ref.gatekeeperClient,\n      networkConfig = _ref.networkConfig;\n  var refreshTimeoutId = state.refreshTimeoutId,\n      gatewayToken = state.gatewayToken,\n      gatekeeperNetworkAddress = state.gatekeeperNetworkAddress,\n      ownerSigns = state.ownerSigns,\n      walletAddress = state.walletAddress;\n\n  var logDebug = function logDebug(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(\"[useRefresh] \".concat(message), obj);\n  };\n\n  var setTimeoutForRefresh = (0, react_1.useRef)(null);\n  /**\n   * Start a timeout based on the expiration of the GatewayToken that will check if a token needs to be refreshed\n   * event, triggering the refreshFlow\n   */\n\n  var checkForRefreshWithTimeout = (0, react_1.useCallback)(function () {\n    logDebug('Checking if refresh required', refreshTimeoutId);\n    dispatch({\n      type: 'refresh_status_check'\n    });\n\n    if (!refreshTimeoutId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {\n      var tokenExpirationMarginSeconds = networkConfig.tokenExpirationMarginSeconds;\n      var checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);\n      var timeoutId = setTimeout(function () {\n        var shouldRefresh = (0, tokenUtils_1.isTokenRefreshRequired)({\n          gatewayToken: gatewayToken,\n          tokenExpirationMarginSeconds: tokenExpirationMarginSeconds\n        });\n\n        if (shouldRefresh) {\n          logDebug('Refreshing Gateway Token');\n          dispatch({\n            type: 'refresh_start'\n          });\n          dispatch({\n            type: 'civicPass_check_token_status'\n          });\n          return;\n        }\n\n        logDebug('Skipping refresh', {\n          gatewayToken: gatewayToken,\n          tokenExpirationMarginSeconds: tokenExpirationMarginSeconds\n        });\n        dispatch({\n          type: 'refresh_complete'\n        });\n      }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion\n\n      logDebug('Setting token refresh timeout', {\n        expiring: gatewayToken.expiryTime,\n        checkForExpirationIntervalMilliseconds: checkForExpirationIntervalMilliseconds,\n        margin: tokenExpirationMarginSeconds\n      });\n      dispatch({\n        type: 'refresh_set_timeout',\n        refreshTimeoutId: timeoutId\n      });\n    }\n  }, [refreshTimeoutId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);\n  /**\n   * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n   * endpoint.\n   * On server error (5xx), retry with backoff.\n   * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n   */\n\n  var refreshToken = (0, react_1.useCallback)(function (useWallet) {\n    return /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2) {\n        var proof, payload, refreshResult;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                proof = _ref2.proof, payload = _ref2.payload;\n                logDebug('Refresh token', {\n                  payload: payload,\n                  proof: proof\n                });\n                dispatch({\n                  type: 'refresh_with_powo_in_progress'\n                });\n                _context.next = 5;\n                return gatekeeperClient().refreshToken({\n                  wallet: useWallet,\n                  payload: payload,\n                  proof: proof,\n                  ownerSigns: ownerSigns !== null && ownerSigns !== void 0 ? ownerSigns : false\n                });\n\n              case 5:\n                refreshResult = _context.sent;\n                dispatch({\n                  type: 'refresh_token_success'\n                });\n                return _context.abrupt(\"return\", refreshResult.transaction);\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n  }, [gatewayToken, gatekeeperClient, checkForRefreshWithTimeout, ownerSigns, walletAddress]);\n  /**\n   * wait until a gateway token exists in state before resolving the promise\n   */\n\n  var waitForUnexpiredGatewayToken = (0, react_1.useCallback)(function () {\n    return new Promise(function (resolve, reject) {\n      logDebug('Waiting for unexpired token');\n\n      if (setTimeoutForRefresh.current) {\n        logDebug('Clearing interval for gatewayToken', setTimeoutForRefresh.current);\n        clearTimeout(setTimeoutForRefresh.current);\n        setTimeoutForRefresh.current = null;\n      }\n\n      var isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);\n\n      if (!isExpired) {\n        logDebug('Gateway token is unexpired', gatewayToken);\n        resolve();\n        return;\n      }\n\n      setTimeoutForRefresh.current = setTimeout(function () {\n        reject(new Error('Gateway token refresh has not been updated onChain'));\n      }, networkConfig.waitForTokenRefreshTimoutMilliseconds);\n      logDebug('Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);\n    });\n  }, [gatewayToken, setTimeoutForRefresh, gatekeeperNetworkAddress]);\n  return {\n    checkForRefreshWithTimeout: checkForRefreshWithTimeout,\n    refreshToken: refreshToken,\n    waitForUnexpiredGatewayToken: waitForUnexpiredGatewayToken\n  };\n};\n\nexports.default = useRefresh;","map":{"version":3,"sources":["/workspace/0x2Hacks.github.io/candy-machine-ui/node_modules/@civic/common-gateway-react/dist/esm/useHooks/useRefresh.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","reducer","react_1","require","utils_1","logger_1","types_1","tokenUtils_1","state","action","type","assign","walletPowoInProgress","powoFinished","powoRequested","undefined","refreshInProgress","gatewayStatus","GatewayStatus","REFRESH_TOKEN_REQUIRED","refreshTokenState","RefreshTokenState","IN_PROGRESS","COMPLETED","statusFromToken","gatewayToken","refreshTimeoutId","civicPass","responsePayload","FAILED","renderIframe","iframeMinimized","CHECKING","WAIT_FOR_ON_CHAIN","useRefresh","dispatch","stage","gatekeeperClient","networkConfig","gatekeeperNetworkAddress","ownerSigns","walletAddress","logDebug","message","obj","default","debug","setTimeoutForRefresh","useRef","checkForRefreshWithTimeout","useCallback","expiryTime","tokenExpirationMarginSeconds","checkForExpirationIntervalMilliseconds","getTokenRefreshIntervalMilliseconds","timeoutId","setTimeout","shouldRefresh","isTokenRefreshRequired","expiring","margin","refreshToken","useWallet","proof","payload","wallet","refreshResult","transaction","waitForUnexpiredGatewayToken","Promise","resolve","reject","current","clearTimeout","isExpired","hasExpired","Error","waitForTokenRefreshTimoutMilliseconds"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reducer = void 0;\nconst react_1 = require(\"react\");\nconst utils_1 = require(\"../useReducer/utils\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst types_1 = require(\"../types\");\nconst tokenUtils_1 = require(\"../utils/tokenUtils\");\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case 'refresh_start': {\n            return Object.assign(Object.assign({}, state), { walletPowoInProgress: false, powoFinished: false, powoRequested: undefined, refreshInProgress: true, gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED });\n        }\n        case 'refresh_status_check': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS });\n        }\n        case 'refresh_complete': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.COMPLETED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), refreshTimeoutId: undefined, civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });\n        }\n        case 'refresh_failed': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.FAILED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });\n        }\n        case 'refresh_with_powo_in_progress': {\n            return Object.assign(Object.assign({}, state), { renderIframe: false, iframeMinimized: true, gatewayStatus: types_1.GatewayStatus.CHECKING });\n        }\n        case 'refresh_clear_timeout':\n            return Object.assign(Object.assign({}, state), { refreshTimeoutId: undefined });\n        case 'refresh_set_timeout':\n            return Object.assign(Object.assign({}, state), { refreshTimeoutId: action.refreshTimeoutId });\n        case 'refresh_token_success':\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN });\n        default:\n            return state;\n    }\n};\nexports.reducer = reducer;\nconst useRefresh = ({ stage, gatekeeperClient, networkConfig, }, state, dispatch) => {\n    const { refreshTimeoutId, gatewayToken, gatekeeperNetworkAddress, ownerSigns, walletAddress } = state;\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useRefresh] ${message}`, obj);\n    const setTimeoutForRefresh = (0, react_1.useRef)(null);\n    /**\n     * Start a timeout based on the expiration of the GatewayToken that will check if a token needs to be refreshed\n     * event, triggering the refreshFlow\n     */\n    const checkForRefreshWithTimeout = (0, react_1.useCallback)(() => {\n        logDebug('Checking if refresh required', refreshTimeoutId);\n        dispatch({ type: 'refresh_status_check' });\n        if (!refreshTimeoutId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {\n            const { tokenExpirationMarginSeconds } = networkConfig;\n            const checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);\n            const timeoutId = setTimeout(() => {\n                const shouldRefresh = (0, tokenUtils_1.isTokenRefreshRequired)({ gatewayToken, tokenExpirationMarginSeconds });\n                if (shouldRefresh) {\n                    logDebug('Refreshing Gateway Token');\n                    dispatch({ type: 'refresh_start' });\n                    dispatch({ type: 'civicPass_check_token_status' });\n                    return;\n                }\n                logDebug('Skipping refresh', { gatewayToken, tokenExpirationMarginSeconds });\n                dispatch({ type: 'refresh_complete' });\n            }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion\n            logDebug('Setting token refresh timeout', {\n                expiring: gatewayToken.expiryTime,\n                checkForExpirationIntervalMilliseconds,\n                margin: tokenExpirationMarginSeconds,\n            });\n            dispatch({\n                type: 'refresh_set_timeout',\n                refreshTimeoutId: timeoutId,\n            });\n        }\n    }, [refreshTimeoutId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);\n    /**\n     * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n     * endpoint.\n     * On server error (5xx), retry with backoff.\n     * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n     */\n    const refreshToken = (0, react_1.useCallback)((useWallet) => async ({ proof, payload }) => {\n        logDebug('Refresh token', { payload, proof });\n        dispatch({ type: 'refresh_with_powo_in_progress' });\n        const refreshResult = await gatekeeperClient().refreshToken({\n            wallet: useWallet,\n            payload,\n            proof,\n            ownerSigns: ownerSigns !== null && ownerSigns !== void 0 ? ownerSigns : false,\n        });\n        dispatch({ type: 'refresh_token_success' });\n        return refreshResult.transaction;\n    }, [gatewayToken, gatekeeperClient, checkForRefreshWithTimeout, ownerSigns, walletAddress]);\n    /**\n     * wait until a gateway token exists in state before resolving the promise\n     */\n    const waitForUnexpiredGatewayToken = (0, react_1.useCallback)(() => {\n        return new Promise((resolve, reject) => {\n            logDebug('Waiting for unexpired token');\n            if (setTimeoutForRefresh.current) {\n                logDebug('Clearing interval for gatewayToken', setTimeoutForRefresh.current);\n                clearTimeout(setTimeoutForRefresh.current);\n                setTimeoutForRefresh.current = null;\n            }\n            const isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);\n            if (!isExpired) {\n                logDebug('Gateway token is unexpired', gatewayToken);\n                resolve();\n                return;\n            }\n            setTimeoutForRefresh.current = setTimeout(() => {\n                reject(new Error('Gateway token refresh has not been updated onChain'));\n            }, networkConfig.waitForTokenRefreshTimoutMilliseconds);\n            logDebug('Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);\n        });\n    }, [gatewayToken, setTimeoutForRefresh, gatekeeperNetworkAddress]);\n    return {\n        checkForRefreshWithTimeout,\n        refreshToken,\n        waitForUnexpiredGatewayToken,\n    };\n};\nexports.default = useRefresh;\n"]},"metadata":{},"sourceType":"script"}