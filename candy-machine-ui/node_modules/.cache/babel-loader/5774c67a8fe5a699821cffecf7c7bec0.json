{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reducer = void 0;\n\nconst react_1 = require(\"react\");\n\nconst types_1 = require(\"../types\");\n\nconst logger_1 = __importDefault(require(\"../logger\"));\n\nconst useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'tokenOnChainNotFound':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: types_1.GatewayStatus.NOT_REQUESTED\n      });\n\n    case 'tokenOnChainError':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: types_1.GatewayStatus.ERROR\n      });\n\n    default:\n      return state;\n  }\n};\n\nexports.reducer = reducer;\n\nconst useChain = (_ref, state, dispatch) => {\n  let {\n    wallet,\n    chainImplementation,\n    networkConfig\n  } = _ref;\n  const {\n    expectWalletConnected\n  } = (0, useWalletHooks_1.default)(wallet, state, dispatch);\n  const {\n    gatekeeperRecordState,\n    gatewayToken\n  } = state;\n\n  const logDebug = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(`[useChain] ${message}`, obj);\n  };\n\n  const logError = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.error(`[useChain] ${message}`, obj);\n  };\n\n  const removeOnChainListener = listernerId => {\n    try {\n      logDebug('Removing onChainListener with id: ', listernerId);\n      chainImplementation.removeOnGatewayTokenChangeListener(listernerId);\n    } catch (error) {\n      logError('Error removing on chain listener', error);\n    }\n  };\n  /**\n   * listen to the blockchain for any token changes and update local state if there are\n   */\n\n\n  const addTokenChangeListeners = // eslint-disable-next-line @typescript-eslint/no-shadow\n  async gatewayToken => {\n    const tokenChangeCallback = token => {\n      dispatch({\n        type: 'tokenChange',\n        token\n      });\n      dispatch({\n        type: 'civicPass_check_token_status',\n        token\n      });\n    };\n\n    const listernerId = await chainImplementation.addOnGatewayTokenChangeListener(gatewayToken, tokenChangeCallback);\n    logDebug('Adding onChainListener with id: ', listernerId);\n    return listernerId;\n  };\n\n  (0, react_1.useEffect)(() => {\n    let listernerId;\n\n    const addListenerIfToken = async () => {\n      if (gatewayToken) {\n        addTokenChangeListeners(gatewayToken).then(id => {\n          listernerId = id;\n        }).catch(error => {\n          logger_1.default.error('onChainListener error', error);\n        });\n      }\n    };\n\n    addListenerIfToken().catch(logger_1.default.error);\n    return () => {\n      if (listernerId) {\n        removeOnChainListener(listernerId);\n      }\n    };\n  }, [gatekeeperRecordState, gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.identifier]);\n  /**\n   * use the on-chain lookup utility findGatewayToken to retrieve a token from the chain\n   * when a token is found, set up listeners to monitor any on-chain changes\n   */\n\n  const dispatchTokenFromChain = async () => {\n    const connectedWallet = expectWalletConnected();\n\n    try {\n      logDebug('Fetching token from chain');\n      const token = await chainImplementation.findGatewayToken();\n\n      if (!token) {\n        dispatch({\n          type: 'tokenOnChainNotFound'\n        });\n        return;\n      }\n\n      logDebug('Token found', token);\n      dispatch({\n        type: 'tokenChange',\n        token\n      }); // Determine if we should show the civicPass dialog when we have a gateway token\n\n      const shouldDispatchTokenFromChain = gatekeeperRecordState && [types_1.GatekeeperAPIStatus.ISSUED_EXPIRED, types_1.GatekeeperAPIStatus.ISSUED_EXPIRY_APPROACHING, types_1.GatekeeperAPIStatus.ISSUED_LOCATION_NOT_SUPPORTED, types_1.GatekeeperAPIStatus.ISSUED_VPN_NOT_SUPPORTED].includes(gatekeeperRecordState);\n      if (!shouldDispatchTokenFromChain) return;\n      dispatch({\n        type: 'civicPass_check_token_status',\n        token\n      });\n    } catch (error) {\n      logError(`Error getting token from chain for ${connectedWallet.publicKey}`, error);\n      dispatch({\n        type: 'tokenOnChainError'\n      });\n      throw error;\n    }\n  };\n  /**\n   * Determine if we should fetch a token from chain based on the gatekeeper record state\n   */\n\n\n  (0, react_1.useEffect)(() => {\n    const shouldDispatchTokenFromChain = gatekeeperRecordState && [types_1.GatekeeperAPIStatus.ISSUED, types_1.GatekeeperAPIStatus.ISSUED_EXPIRED, types_1.GatekeeperAPIStatus.ISSUED_EXPIRY_APPROACHING, types_1.GatekeeperAPIStatus.REQUESTED, types_1.GatekeeperAPIStatus.ISSUED_LOCATION_NOT_SUPPORTED, types_1.GatekeeperAPIStatus.ISSUED_VPN_NOT_SUPPORTED, types_1.GatekeeperAPIStatus.SERVER_FAILURE].includes(gatekeeperRecordState);\n    if (!shouldDispatchTokenFromChain) return;\n    dispatchTokenFromChain();\n  }, [gatekeeperRecordState, chainImplementation]);\n  /**\n   * Check token on chain if checking the record status is not required\n   * This will then run when the component is mounted instead of after the record has been fetched\n   */\n\n  (0, react_1.useEffect)(() => {\n    if (networkConfig.requiresGatekeeperRecordStatusCheck) return;\n    dispatchTokenFromChain();\n  }, [networkConfig.requiresGatekeeperRecordStatusCheck, chainImplementation]);\n  return {\n    addTokenChangeListeners,\n    dispatchTokenFromChain\n  };\n};\n\nexports.default = useChain;","map":{"version":3,"sources":["/workspace/0x2Hacks.github.io/candy-machine-ui/node_modules/@civic/common-gateway-react/dist/esm/useHooks/useChain.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","reducer","react_1","require","types_1","logger_1","useWalletHooks_1","state","action","type","assign","gatewayStatus","GatewayStatus","NOT_REQUESTED","ERROR","useChain","dispatch","wallet","chainImplementation","networkConfig","expectWalletConnected","default","gatekeeperRecordState","gatewayToken","logDebug","message","obj","debug","logError","error","removeOnChainListener","listernerId","removeOnGatewayTokenChangeListener","addTokenChangeListeners","tokenChangeCallback","token","addOnGatewayTokenChangeListener","useEffect","addListenerIfToken","then","id","catch","identifier","dispatchTokenFromChain","connectedWallet","findGatewayToken","shouldDispatchTokenFromChain","GatekeeperAPIStatus","ISSUED_EXPIRED","ISSUED_EXPIRY_APPROACHING","ISSUED_LOCATION_NOT_SUPPORTED","ISSUED_VPN_NOT_SUPPORTED","includes","publicKey","ISSUED","REQUESTED","SERVER_FAILURE","requiresGatekeeperRecordStatusCheck"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reducer = void 0;\nconst react_1 = require(\"react\");\nconst types_1 = require(\"../types\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case 'tokenOnChainNotFound':\n            return Object.assign(Object.assign({}, state), { gatewayStatus: types_1.GatewayStatus.NOT_REQUESTED });\n        case 'tokenOnChainError':\n            return Object.assign(Object.assign({}, state), { gatewayStatus: types_1.GatewayStatus.ERROR });\n        default:\n            return state;\n    }\n};\nexports.reducer = reducer;\nconst useChain = ({ wallet, chainImplementation, networkConfig, }, state, dispatch) => {\n    const { expectWalletConnected } = (0, useWalletHooks_1.default)(wallet, state, dispatch);\n    const { gatekeeperRecordState, gatewayToken } = state;\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useChain] ${message}`, obj);\n    const logError = (message, obj = null) => logger_1.default.error(`[useChain] ${message}`, obj);\n    const removeOnChainListener = (listernerId) => {\n        try {\n            logDebug('Removing onChainListener with id: ', listernerId);\n            chainImplementation.removeOnGatewayTokenChangeListener(listernerId);\n        }\n        catch (error) {\n            logError('Error removing on chain listener', error);\n        }\n    };\n    /**\n     * listen to the blockchain for any token changes and update local state if there are\n     */\n    const addTokenChangeListeners = \n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    async (gatewayToken) => {\n        const tokenChangeCallback = (token) => {\n            dispatch({ type: 'tokenChange', token });\n            dispatch({ type: 'civicPass_check_token_status', token });\n        };\n        const listernerId = await chainImplementation.addOnGatewayTokenChangeListener(gatewayToken, tokenChangeCallback);\n        logDebug('Adding onChainListener with id: ', listernerId);\n        return listernerId;\n    };\n    (0, react_1.useEffect)(() => {\n        let listernerId;\n        const addListenerIfToken = async () => {\n            if (gatewayToken) {\n                addTokenChangeListeners(gatewayToken)\n                    .then((id) => {\n                    listernerId = id;\n                })\n                    .catch((error) => {\n                    logger_1.default.error('onChainListener error', error);\n                });\n            }\n        };\n        addListenerIfToken().catch(logger_1.default.error);\n        return () => {\n            if (listernerId) {\n                removeOnChainListener(listernerId);\n            }\n        };\n    }, [gatekeeperRecordState, gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.identifier]);\n    /**\n     * use the on-chain lookup utility findGatewayToken to retrieve a token from the chain\n     * when a token is found, set up listeners to monitor any on-chain changes\n     */\n    const dispatchTokenFromChain = async () => {\n        const connectedWallet = expectWalletConnected();\n        try {\n            logDebug('Fetching token from chain');\n            const token = await chainImplementation.findGatewayToken();\n            if (!token) {\n                dispatch({ type: 'tokenOnChainNotFound' });\n                return;\n            }\n            logDebug('Token found', token);\n            dispatch({ type: 'tokenChange', token });\n            // Determine if we should show the civicPass dialog when we have a gateway token\n            const shouldDispatchTokenFromChain = gatekeeperRecordState &&\n                [\n                    types_1.GatekeeperAPIStatus.ISSUED_EXPIRED,\n                    types_1.GatekeeperAPIStatus.ISSUED_EXPIRY_APPROACHING,\n                    types_1.GatekeeperAPIStatus.ISSUED_LOCATION_NOT_SUPPORTED,\n                    types_1.GatekeeperAPIStatus.ISSUED_VPN_NOT_SUPPORTED,\n                ].includes(gatekeeperRecordState);\n            if (!shouldDispatchTokenFromChain)\n                return;\n            dispatch({ type: 'civicPass_check_token_status', token });\n        }\n        catch (error) {\n            logError(`Error getting token from chain for ${connectedWallet.publicKey}`, error);\n            dispatch({ type: 'tokenOnChainError' });\n            throw error;\n        }\n    };\n    /**\n     * Determine if we should fetch a token from chain based on the gatekeeper record state\n     */\n    (0, react_1.useEffect)(() => {\n        const shouldDispatchTokenFromChain = gatekeeperRecordState &&\n            [\n                types_1.GatekeeperAPIStatus.ISSUED,\n                types_1.GatekeeperAPIStatus.ISSUED_EXPIRED,\n                types_1.GatekeeperAPIStatus.ISSUED_EXPIRY_APPROACHING,\n                types_1.GatekeeperAPIStatus.REQUESTED,\n                types_1.GatekeeperAPIStatus.ISSUED_LOCATION_NOT_SUPPORTED,\n                types_1.GatekeeperAPIStatus.ISSUED_VPN_NOT_SUPPORTED,\n                types_1.GatekeeperAPIStatus.SERVER_FAILURE,\n            ].includes(gatekeeperRecordState);\n        if (!shouldDispatchTokenFromChain)\n            return;\n        dispatchTokenFromChain();\n    }, [gatekeeperRecordState, chainImplementation]);\n    /**\n     * Check token on chain if checking the record status is not required\n     * This will then run when the component is mounted instead of after the record has been fetched\n     */\n    (0, react_1.useEffect)(() => {\n        if (networkConfig.requiresGatekeeperRecordStatusCheck)\n            return;\n        dispatchTokenFromChain();\n    }, [networkConfig.requiresGatekeeperRecordStatusCheck, chainImplementation]);\n    return {\n        addTokenChangeListeners,\n        dispatchTokenFromChain,\n    };\n};\nexports.default = useChain;\n"]},"metadata":{},"sourceType":"script"}