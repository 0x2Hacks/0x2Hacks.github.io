"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GatewayTokenActionCreatorImplementation = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const types_1 = require("../types");
const logger_1 = __importDefault(require("../logger"));
const utils_1 = require("./utils");
const GatewayTokenActionCreatorImplementation = ({ wallet, chainImplementation, gatekeeperClient, dispatch, networkConfig, ownerSigns, }) => {
    const logDebug = (message, obj = null) => logger_1.default.debug(`[useChain] ${message}`, obj);
    const logError = (message, obj = null) => logger_1.default.error(`[useChain] ${message}`, obj);
    const isTokenCreated = (code) => code === types_1.GatekeeperAPIStatus.ISSUED;
    const isTokenPending = (code) => code === types_1.GatekeeperAPIStatus.REQUESTED;
    const isRequestedRetriesExhausted = (code) => code === types_1.GatekeeperAPIStatus.REQUESTED_RETRIES_EXHAUSTED;
    const isFailure = (code) => !isTokenPending(code) && !isRequestedRetriesExhausted(code) && code >= 400;
    const pollForActiveOnChainToken = async (pollChainNumberRetries = networkConfig.pollChainNumberRetries) => {
        return (0, utils_1.pollUntilConditionMet)(chainImplementation.findGatewayToken, (onChainToken) => {
            if (!onChainToken)
                return false; // keep polling
            if (!onChainToken.expiryTime)
                return true;
            if (onChainToken.state === types_1.State.ACTIVE)
                return true;
            throw new Error('Token found but not ACTIVE');
        }, networkConfig.pollChainIntervalMilliseconds, pollChainNumberRetries);
    };
    const waitForGatewayToken = async (pollChainNumberRetries = networkConfig.pollChainNumberRetries) => {
        // poll the gatekeeper until we have a status for a created record
        // if we don't get a created token, then we consider it a failure
        try {
            // Show the awaiting transaction screen if this is an owner signs transaction
            if (ownerSigns) {
                dispatch({ type: 'civicPass_awaiting_owner_transaction' });
            }
            const token = await pollForActiveOnChainToken(pollChainNumberRetries);
            logDebug('Result from pollForActiveOnChainToken', token);
            if (!token) {
                logError('Token not found onChain');
                throw new Error('Token not found onChain');
            }
            dispatch({ type: 'tokenChange', token });
            dispatch({ type: 'civicPass_check_token_status', token });
            return;
        }
        catch (error) {
            logError('Error polling for active token on chain', error);
            // If owner signs is true then fail the flow without checking the gatekeeper
            if (ownerSigns) {
                logError('Failed to find Gateway token on-chain with ownerSigns:true, failing');
                dispatch({ type: 'civicPass_owner_transaction_timeout' });
                return;
            }
            logError('Failed to find Gateway token on-chain with ownerSigns:false, checking with gatekeeper');
            const gkApiStatus = await gatekeeperClient().getGatekeeperStatus(wallet.publicKey);
            if (isRequestedRetriesExhausted(gkApiStatus)) {
                logError('Retried exhausted', { gkApiStatus });
                dispatch({ type: 'civicPass_requested_retries_exhausted' });
                return;
            }
            // if the token is still pending or in review then keep polling on-chain
            if (isTokenPending(gkApiStatus)) {
                // we don't want to wait the whole amount of time if we've got to here, so just 4 retries = 3 x 2 seconds, a further
                // 6 seconds before we will ask the GK API for status again
                await waitForGatewayToken(3);
            }
            // retries have been exhausted and we still don't have a token
            // or the gatekeeper threw an error during issuance attempt
            if (isTokenCreated(gkApiStatus) || isFailure(gkApiStatus)) {
                logError('Failed to find Gateway token with gatekeeper status code', types_1.GatekeeperAPIStatus[gkApiStatus]);
                dispatch({ type: 'tokenNotFoundError' });
            }
        }
    };
    return {
        waitForGatewayToken,
    };
};
exports.GatewayTokenActionCreatorImplementation = GatewayTokenActionCreatorImplementation;
