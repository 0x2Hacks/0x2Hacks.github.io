"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reducer = void 0;
const react_1 = require("react");
const utils_1 = require("../useReducer/utils");
const logger_1 = __importDefault(require("../logger"));
const types_1 = require("../types");
const tokenUtils_1 = require("../utils/tokenUtils");
const reducer = (state, action) => {
    switch (action.type) {
        case 'refresh_start': {
            return Object.assign(Object.assign({}, state), { walletPowoInProgress: false, powoFinished: false, powoRequested: undefined, refreshInProgress: true, gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED });
        }
        case 'refresh_status_check': {
            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS });
        }
        case 'refresh_complete': {
            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.COMPLETED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), refreshTimeoutId: undefined, civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });
        }
        case 'refresh_failed': {
            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.FAILED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });
        }
        case 'refresh_with_powo_in_progress': {
            return Object.assign(Object.assign({}, state), { renderIframe: false, iframeMinimized: true, gatewayStatus: types_1.GatewayStatus.CHECKING });
        }
        case 'refresh_clear_timeout':
            return Object.assign(Object.assign({}, state), { refreshTimeoutId: undefined });
        case 'refresh_set_timeout':
            return Object.assign(Object.assign({}, state), { refreshTimeoutId: action.refreshTimeoutId });
        case 'refresh_token_success':
            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN });
        default:
            return state;
    }
};
exports.reducer = reducer;
const useRefresh = ({ stage, gatekeeperClient, networkConfig, }, state, dispatch) => {
    const { refreshTimeoutId, gatewayToken, gatekeeperNetworkAddress, ownerSigns, walletAddress } = state;
    const logDebug = (message, obj = null) => logger_1.default.debug(`[useRefresh] ${message}`, obj);
    const setTimeoutForRefresh = (0, react_1.useRef)(null);
    /**
     * Start a timeout based on the expiration of the GatewayToken that will check if a token needs to be refreshed
     * event, triggering the refreshFlow
     */
    const checkForRefreshWithTimeout = (0, react_1.useCallback)(() => {
        logDebug('Checking if refresh required', refreshTimeoutId);
        dispatch({ type: 'refresh_status_check' });
        if (!refreshTimeoutId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {
            const { tokenExpirationMarginSeconds } = networkConfig;
            const checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);
            const timeoutId = setTimeout(() => {
                const shouldRefresh = (0, tokenUtils_1.isTokenRefreshRequired)({ gatewayToken, tokenExpirationMarginSeconds });
                if (shouldRefresh) {
                    logDebug('Refreshing Gateway Token');
                    dispatch({ type: 'refresh_start' });
                    dispatch({ type: 'civicPass_check_token_status' });
                    return;
                }
                logDebug('Skipping refresh', { gatewayToken, tokenExpirationMarginSeconds });
                dispatch({ type: 'refresh_complete' });
            }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion
            logDebug('Setting token refresh timeout', {
                expiring: gatewayToken.expiryTime,
                checkForExpirationIntervalMilliseconds,
                margin: tokenExpirationMarginSeconds,
            });
            dispatch({
                type: 'refresh_set_timeout',
                refreshTimeoutId: timeoutId,
            });
        }
    }, [refreshTimeoutId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);
    /**
     * use the passed proof of wallet ownership string to call the gatekeeper refresh token
     * endpoint.
     * On server error (5xx), retry with backoff.
     * On all other errors, e.g. 400, move to a REFRESH_FAILED state.
     */
    const refreshToken = (0, react_1.useCallback)((useWallet) => async ({ proof, payload }) => {
        logDebug('Refresh token', { payload, proof });
        dispatch({ type: 'refresh_with_powo_in_progress' });
        const refreshResult = await gatekeeperClient().refreshToken({
            wallet: useWallet,
            payload,
            proof,
            ownerSigns: ownerSigns !== null && ownerSigns !== void 0 ? ownerSigns : false,
        });
        dispatch({ type: 'refresh_token_success' });
        return refreshResult.transaction;
    }, [gatewayToken, gatekeeperClient, checkForRefreshWithTimeout, ownerSigns, walletAddress]);
    /**
     * wait until a gateway token exists in state before resolving the promise
     */
    const waitForUnexpiredGatewayToken = (0, react_1.useCallback)(() => {
        return new Promise((resolve, reject) => {
            logDebug('Waiting for unexpired token');
            if (setTimeoutForRefresh.current) {
                logDebug('Clearing interval for gatewayToken', setTimeoutForRefresh.current);
                clearTimeout(setTimeoutForRefresh.current);
                setTimeoutForRefresh.current = null;
            }
            const isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);
            if (!isExpired) {
                logDebug('Gateway token is unexpired', gatewayToken);
                resolve();
                return;
            }
            setTimeoutForRefresh.current = setTimeout(() => {
                reject(new Error('Gateway token refresh has not been updated onChain'));
            }, networkConfig.waitForTokenRefreshTimoutMilliseconds);
            logDebug('Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);
        });
    }, [gatewayToken, setTimeoutForRefresh, gatekeeperNetworkAddress]);
    return {
        checkForRefreshWithTimeout,
        refreshToken,
        waitForUnexpiredGatewayToken,
    };
};
exports.default = useRefresh;
